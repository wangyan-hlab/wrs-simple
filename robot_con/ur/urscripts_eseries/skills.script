def myProg():

    global Fx = 0.0
    global Fy = 0.0
    global Fz = 0.0
    global Mx = 0.0
    global My = 0.0
    global Mz = 0.0

    def get_sensor_fx():
        return Fx
    end

    def get_sensor_fy():
        return Fy
    end

    def get_sensor_fz():
        return Fz
    end

    def get_sensor_mx():
        return Mx
    end

    def get_sensor_my():
        return My
    end

    def get_sensor_mz():
        return Mz
    end

    thread read_force():
        while True:
            sk_sensor_data = get_tcp_force()
            Fx = sk_sensor_data[0]
            Fy = sk_sensor_data[1]
            Fz = sk_sensor_data[2]
            Mx = sk_sensor_data[3]
            My = sk_sensor_data[4]
            Mz = sk_sensor_data[5]
            sleep(.002)
        end
    end
    run read_force()
    textmsg("Starting force sensing")

    ################################
    # gripper
    ################################
    #aliases for the gripper variable names
    ACT = 1
    GTO = 2
    ATR = 3
    ARD = 4
    FOR = 5
    SPE = 6
    OBJ = 7
    STA = 8
    FLT = 9
    POS = 10
    PRE = 11

    def sk_init_connection(gripper_sid=9, gripper_socket="1"):
        socket_open("127.0.0.1",63352, gripper_socket)
        socket_set_var("SID", gripper_sid,  gripper_socket)
        ack = socket_read_byte_list(3, gripper_socket)
    end

    def sk_set_sid(gripper_sid=9, gripper_socket="1"):
        socket_set_var("SID", gripper_sid,  gripper_socket)
        sync()
        return is_ack(socket_read_byte_list(3, gripper_socket))
    end

    def sk_activate(gripper_socket="1"):
        sk_gripper_act = 0
        if (not sk_is_gripper_activated(gripper_socket)):
            sk_reset(gripper_socket)
        end
        sk_set_var(ACT,1, gripper_socket)
    end

    def sk_activate_and_wait(gripper_socket="1"):
        sk_activate(gripper_socket)
        while(not sk_is_gripper_activated(gripper_socket)):
            # wait for activation completed
        end
    end

    def sk_stop(gripper_socket="1"):
        sk_set_var(GTO,0, gripper_socket)
    end

    def sk_reset(gripper_socket="1"):
        sk_gripper_act = 0
        sk_obj_detect = 0
        sk_mov_complete = 0
        sk_set_var(ACT,0, gripper_socket)
        sk_set_var(ATR,0, gripper_socket)
    end

    def sk_auto_release_open_and_wait(gripper_socket="1"):
        sk_set_var(ARD,0, gripper_socket)
        sk_set_var(ACT,1, gripper_socket)
        sk_set_var(ATR,1, gripper_socket)
        gFLT = sk_get_var(FLT, 2, gripper_socket)
        while(not is_FLT_autorelease_completed(gFLT)):
            gFLT = sk_get_var(FLT, 2, gripper_socket)
        end
    end

    def sk_auto_release_close_and_wait(gripper_socket="1"):
        sk_set_var(ARD,1, gripper_socket)
        sk_set_var(ACT,1, gripper_socket)
        sk_set_var(ATR,1, gripper_socket)
        gFLT = sk_get_var(FLT, 2, gripper_socket)
        while(not is_FLT_autorelease_completed(gFLT)):
            gFLT = sk_get_var(FLT, 2, gripper_socket)
        end
    end

    def sk_set_force(force, gripper_socket="1"):
        sk_set_var(FOR,force, gripper_socket)
    end

    def sk_set_speed(speed, gripper_socket="1"):
        sk_set_var(SPE,speed, gripper_socket)
    end

    def sk_open(gripper_socket="1"):
        sk_move(0, gripper_socket)
    end

    def sk_close(gripper_socket="1"):
        sk_move(255, gripper_socket)
    end

    def sk_open_and_wait(gripper_socket="1"):
        sk_move_and_wait(0, gripper_socket)
    end

    def sk_close_and_wait(gripper_socket="1"):
        sk_move_and_wait(255, gripper_socket)
    end

    def sk_move(pos, gripper_socket="1"):
        sk_mov_complete = 0
        sk_obj_detect = 0
        sk_set_pos(pos, gripper_socket)
        sk_go_to(gripper_socket)
    end

    def sk_move_and_wait(pos, gripper_socket="1"):
        sk_move(pos, gripper_socket)
        while (not sk_is_motion_complete(gripper_socket)):
            # wait for motion completed
            sleep(0.01)
            sync()
        end
        # following code used for compatibility with previous versions
        sk_is_object_detected(gripper_socket)
        if (sk_obj_detect != 1):
            sk_mov_complete = 1
        end
    end

    def sk_wait(gripper_socket="1"):
        # Wait for the gripper motion to complete
        while (not sk_is_motion_complete(gripper_socket)):
            # wait for motion completed
            sleep(0.01)
            sync()
        end
        # following code used for compatibility with previous versions
        sk_is_object_detected(gripper_socket)
        if (sk_obj_detect != 1):
            sk_mov_complete = 1
        end
    end

    def sk_go_to(gripper_socket="1"):
        sk_set_var(GTO,1, gripper_socket)
    end

    # reset the rGTO to prevent movement and
    # set the position
    def sk_set_pos(pos, gripper_socket="1"):
        sk_set_var(GTO,0, gripper_socket)
        sk_set_var(POS, pos, gripper_socket)
        gPRE = sk_get_var(PRE, 3, gripper_socket)
        pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
        sync()
        while (pre != pos):
            sk_set_var(POS, pos, gripper_socket)
            gPRE = sk_get_var(PRE, 3, gripper_socket)
            pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
            sync()
        end
    end

    def sk_is_motion_complete(gripper_socket="1"):
        sk_mov_complete = 0
        gOBJ = sk_get_var(OBJ, 1, gripper_socket)
        sleep(0.01)
        if (is_OBJ_gripper_at_position(gOBJ)):
            sk_mov_complete = 1
            return True
        end
        if (is_OBJ_object_detected(gOBJ)):
            sk_mov_complete = 1
            return True
        end
        return False
    end

    def sk_is_gripper_activated(gripper_socket="1"):
        gSTA = sk_get_var(STA, 1, gripper_socket)
        if(is_STA_gripper_activated(gSTA)):
            sk_gripper_act = 1
            return True
        else:
            sk_gripper_act = 0
            return False
        end
    end

    def sk_is_object_detected(gripper_socket="1"):
        gOBJ = sk_get_var(OBJ, 1, gripper_socket)
        if(is_OBJ_object_detected(gOBJ)):
            sk_obj_detect = 1
            return True
        else:
            sk_obj_detect = 0
            return False
        end
    end

    def sk_current_pos(gripper_socket="1"):
        sk_pos = socket_get_var("POS",gripper_socket)
        sync()
          return sk_pos
        end
        def sk_print_gripper_fault_code(gripper_socket="1"):
        gFLT = sk_get_var(FLT, 2, gripper_socket)
        if(is_FLT_no_fault(gFLT)):
            textmsg("Gripper Fault : ", "No Fault (0x00)")
        elif (is_FLT_action_delayed(gFLT)):
            textmsg("Gripper Fault : ", "Priority Fault: Action delayed, initialization must be completed prior to action (0x05)")
        elif (is_FLT_not_activated(gFLT)):
            textmsg("Gripper Fault : ", "Priority Fault: The activation must be set prior to action (0x07)")
        elif (is_FLT_autorelease_in_progress(gFLT)):
            textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
        elif (is_FLT_overcurrent(gFLT)):
            textmsg("Gripper Fault : ", "Minor Fault: Overcurrent protection tiggered (0x0E)")
        elif (is_FLT_autorelease_completed(gFLT)):
            textmsg("Gripper Fault : ", "Major Fault: Automatic release completed (0x0F)")
        else:
            textmsg("Gripper Fault : ", "Unkwown Fault")
        end
    end

    def sk_print_gripper_num_cycles(gripper_socket="1"):
        socket_send_string("GET NCY",gripper_socket)
        sync()
        string_from_server = socket_read_string(gripper_socket)
        sync()
        if(string_from_server == "0"):
            textmsg("Gripper Cycle Number : ", "Number of cycles is unreachable.")
        else:
            textmsg("Gripper Cycle Number : ", string_from_server)
        end
    end

    def sk_print_gripper_driver_state(gripper_socket="1"):
        socket_send_string("GET DST",gripper_socket)
        sync()
        string_from_server = socket_read_string(gripper_socket)
        sync()
        if(string_from_server == "0"):
            textmsg("Gripper Driver State : ", "sk_STATE_INIT")
        elif(string_from_server == "1"):
            textmsg("Gripper Driver State : ", "sk_STATE_LISTEN")
        elif(string_from_server == "2"):
            textmsg("Gripper Driver State : ", "sk_STATE_READ_INFO")
        elif(string_from_server == "3"):
            textmsg("Gripper Driver State : ", "sk_STATE_ACTIVATION")
        else:
            textmsg("Gripper Driver State : ", "sk_STATE_RUN")
        end
    end

    def sk_print_gripper_serial_number():
        #socket_send_string("GET SNU",gripper_socket)
        #sync()
        #string_from_server = socket_read_string(gripper_socket)
        #sync()
        #textmsg("Gripper Serial Number : ", string_from_server)
    end

    def sk_print_gripper_firmware_version(gripper_socket="1"):
        socket_send_string("GET FWV",gripper_socket)
        sync()
        string_from_server = socket_read_string(gripper_socket)
        sync()
        textmsg("Gripper Firmware Version : ", string_from_server)
    end

    def sk_print_gripper_driver_version(gripper_socket="1"):
        socket_send_string("GET VER",gripper_socket)
        sync()
        string_from_server = socket_read_string(gripper_socket)
        sync()
        textmsg("Gripper Driver Version : ", string_from_server)
    end

    def sk_print_gripper_probleme_connection(gripper_socket="1"):
        socket_send_string("GET PCO",gripper_socket)
        sync()
        string_from_server = socket_read_string(gripper_socket)
        sync()
        if (string_from_server == "0"):
            textmsg("Gripper Connection State : ", "No connection problem detected")
        else:
            textmsg("Gripper Connection State : ", "Connection problem detected")
        end
    end

    # Returns True if list_of_bytes is [3, 'a', 'c', 'k']
    def is_ack(list_of_bytes):
        # list length is not 3
        if (list_of_bytes[0] != 3):
            return False
        end
        # first byte not is 'a'?
        if (list_of_bytes[1] != 97):
            return False
        end
        # first byte not is 'c'?
        if (list_of_bytes[2] != 99):
            return False
        end
        # first byte not is 'k'?
        if (list_of_bytes[3] != 107):
            return False
        end

        return True
    end

    # Returns True if list_of_bytes is not [3, 'a', 'c', 'k']
    def is_not_ack(list_of_bytes):
        if (is_ack(list_of_bytes)):
            return False
        else:
            return True
        end
    end

    def is_STA_gripper_activated (list_of_bytes):
        # list length is not 1
        if (list_of_bytes[0] != 1):
            return False
        end
        # byte is '3'?
        if (list_of_bytes[1] == 51):
            return True
        end
        return False
    end

    # Returns True if list_of_byte is [1, '1'] or [1, '2']
    # Used to test OBJ = 0x1 or OBJ = 0x2
    def is_OBJ_object_detected (list_of_bytes):
        # list length is not 1
        if (list_of_bytes[0] != 1):
            return False
        end
        # byte is '2'?
        if (list_of_bytes[1] == 50):
            return True
        end
        # byte is '1'?
        if (list_of_bytes[1]  == 49):
            return True
        end
        return False
    end

    # Returns True if list_of_byte is [1, '3']
    # Used to test OBJ = 0x3
    def is_OBJ_gripper_at_position (list_of_bytes):
        # list length is not 1
        if (list_of_bytes[0] != 1):
            return False
        end
        # byte is '3'?
        if (list_of_bytes[1] == 51):
            return True
        end
        return False
    end

    def is_not_OBJ_gripper_at_position (list_of_bytes):
        if (is_OBJ_gripper_at_position(list_of_bytes)):
            return False
        else:
            return True
        end
    end

    def is_FLT_no_fault(list_of_bytes):
        # list length is not 2
        if (list_of_bytes[0] != 2):
            return False
        end
        # first byte is '0'?
        if (list_of_bytes[1] != 48):
            return False
        end
        # second byte is '0'?
        if (list_of_bytes[2] != 48):
            return False
        end
        return True
    end

    def is_FLT_action_delayed(list_of_bytes):
        # list length is not 2
        if (list_of_bytes[0] != 2):
            return False
        end
        # first byte is '0'?
        if (list_of_bytes[1] != 48):
            return False
        end
        # second byte is '5'?
        if (list_of_bytes[2] != 53):
            return False
        end
        return True
    end

    def is_FLT_not_activated(list_of_bytes):
        # list length is not 2
        if (list_of_bytes[0] != 2):
            return False
        end
        # first byte is '0'?
        if (list_of_bytes[1] != 48):
            return False
        end
        # second byte is '7'?
        if (list_of_bytes[2] != 55):
            return False
        end
        return True
    end

    def is_FLT_autorelease_in_progress(list_of_bytes):
        # list length is not 2
        if (list_of_bytes[0] != 2):
            return False
        end
        # first byte is '1'?
        if (list_of_bytes[1] != 49):
            return False
        end
        # second byte is '1'?
        if (list_of_bytes[2] != 49):
            return False
        end
        return True

    end

    def is_FLT_overcurrent(list_of_bytes):
        # list length is not 2
        if (list_of_bytes[0] != 2):
            return False
        end
        # first byte is '1'?
        if (list_of_bytes[1] != 49):
            return False
        end
        # second byte is '4'?
        if (list_of_bytes[2] != 52):
            return False
        end
        return True
    end

    def is_FLT_autorelease_completed(list_of_bytes):
        # list length is not 2
        if (list_of_bytes[0] != 2):
            return False
        end
        # first byte is '1'?
        if (list_of_bytes[1] != 49):
            return False
        end
        # second byte is '5'?
        if (list_of_bytes[2] != 53):
            return False
        end
        return True
    end

    def sk_set_var(var_name, var_value, gripper_socket="1"):
        sync()
        if (var_name == ACT):
            socket_set_var("ACT", var_value, gripper_socket)
        elif (var_name == GTO):
            socket_set_var("GTO", var_value, gripper_socket)
        elif (var_name == ATR):
            socket_set_var("ATR", var_value, gripper_socket)
        elif (var_name == ARD):
            socket_set_var("ARD", var_value, gripper_socket)
        elif (var_name == FOR):
            socket_set_var("FOR", var_value, gripper_socket)
        elif (var_name == SPE):
            socket_set_var("SPE", var_value, gripper_socket)
        elif (var_name == POS):
            socket_set_var("POS", var_value, gripper_socket)
        else:
        end
        sync()
        ack = socket_read_byte_list(3, gripper_socket)
        sync()
        while(is_not_ack(ack)):
            textmsg("sk_set_var : retry", " ...")
            textmsg("sk_set_var : var_name = ", var_name)
            textmsg("sk_set_var : var_value = ", var_value)

            if (ack[0] != 0):
                textmsg("sk_set_var : invalid ack value = ", ack)
            end
            socket_set_var(var_name , var_value,gripper_socket)
            sync()
            ack = socket_read_byte_list(3, gripper_socket)
            sync()
        end
    end


    def sk_get_var(var_name, nbr_bytes, gripper_socket="1"):
        if (var_name == FLT):
            socket_send_string("GET FLT",gripper_socket)
            sync()
        elif (var_name == OBJ):
            socket_send_string("GET OBJ",gripper_socket)
            sync()
        elif (var_name == STA):
            socket_send_string("GET STA",gripper_socket)
            sync()
        elif (var_name == PRE):
            socket_send_string("GET PRE",gripper_socket)
            sync()
        else:
        end
        var_value = socket_read_byte_list(nbr_bytes, gripper_socket)
        sync()
        return var_value
    end

    ############################################
    # normalized functions (maps 0-100 to 0-255)
    ############################################

    def sk_set_force_norm(force_norm, gripper_socket="1"):
        force_gripper = norm_to_gripper(force_norm)
        sk_set_force(force_gripper, gripper_socket)
    end

    def sk_set_speed_norm(speed_norm, gripper_socket="1"):
        speed_gripper = norm_to_gripper(speed_norm)
        sk_set_speed(speed_gripper, gripper_socket)
    end

    def sk_move_norm(pos_norm, gripper_socket="1"):
        pos_gripper = norm_to_gripper(pos_norm)
        sk_move(pos_gripper, gripper_socket)
    end

    def sk_move_and_wait_norm(pos_norm, gripper_socket="1"):
        pos_gripper = norm_to_gripper(pos_norm)
        sk_move_and_wait(pos_gripper, gripper_socket)
    end

    def sk_set_pos_norm(pos_norm, gripper_socket="1"):
        pos_gripper = norm_to_gripper(pos_norm)
        sk_set_pos(pos_gripper, gripper_socket)
    end


    def sk_current_pos_norm(gripper_socket="1"):
        pos_gripper = sk_current_pos(gripper_socket)
        pos_norm = gripper_to_norm(pos_gripper)
        return pos_norm
    end

    def gripper_to_norm(value_gripper):
        value_norm = (value_gripper / 255) * 100
        return floor(value_norm)
    end

    def norm_to_gripper(value_norm):
        value_gripper = (value_norm / 100) * 255
        return ceil(value_gripper)
    end

    def sk_get_position():
        return sk_current_pos_norm()
    end

    sk_obj_detect = 0
    sk_init_connection(9, "1")
    connectivity_checked = [-1,-1,-1,-1]
    status_checked = [-1,-1,-1,-1]
    current_speed = [-1,-1,-1,-1]
    current_force = [-1,-1,-1,-1]

    ################################
    # ftsensor
    ################################

    #**************************************
    # FUNCTION: sk_free_turning(nb_half_turns = 3, rotation = "ccw")
    # Description:  The robot will rotate a number of half turn of his joint 6
    #               The gripper will also close before the motion and reopen after each half turn
    # PARAMETER:
    #   nb_half_turns : number of half turns to perform a free spinning with the gripper
    #   rotation :  direction of rotation, "ccw" or "cw"
    #**************************************
    def sk_free_turning(nb_half_turns = 3, rotation = "ccw"):
        if (nb_half_turns<=0):
            popup("parameter nb_half_turns must be positive")
            halt
        else:
            if ((rotation != "ccw") and (rotation != "CCW") and (rotation != "cw") and (rotation != "CW")):
                popup("parameter rotation must be 'cw' or 'ccw'")
                halt
            else:
                Loop_unthight = 0
                pos_init = get_actual_tcp_pose()
                #Store the actual gripper opening
                gripper_start_pos = sk_current_pos("1")
                while (Loop_unthight < nb_half_turns):
                    #Gripper Close
                    sk_close_and_wait("1")
                    sync()
                    #Half turn wrist rotation relative motion
                    if (rotation == "ccw") or (rotation == "CCW"):
                    pose_spin = pose_trans(pos_init,p[0,0,0,0,0,-3.1])
                    else:
                    pose_spin = pose_trans(pos_init,p[0,0,0,0,0,3.1])
                    end
                    movej(pose_spin,a=3.1,v=3.1)
                    #movej(get_inverse_kin(pose_add(get_forward_kin(), pose_sub(p[-.146247506753, -.469291758469, .398027475283, 3.100937522764, -.280788520238, .032861955457],p[-.146276797410, -.469262519355, .398053645881, .199831369643, 3.114543682462, -.044283583314]))), a=3.0962634015954636, v=3.0471975511965976)
                    stopl(5.0)
                    #Return the gripper to his start position
                    sk_move_and_wait(gripper_start_pos,"1")
                    #Move back to initial position
                    movej(pos_init, a=3.14, v=3.14)
                    Loop_unthight = Loop_unthight + 1
                end
            end
        end
    end

    # FUNCTION:  sk_linear_search(direction="Z+",force = 10, speed = 0.004, max_distance = 0.02 )
    # Description: Move the robot on a tool axis until a force is detected within a specified range
    #
    #           The function will return True if the force is detected during the motion
    #           The function will return False if the motion is completed without detecting the force
    # PARAMETER:
    #   Note:   All parameters are optional.
    #   direction : direction of the motion in the tool reference frame   default "z+"
    #   force:      in Newton, If the measured force exceed this value, the motion will be stopped
    #   speed:      in m/s, robot motion speed
    #   max_distance: in meters, define the maximum motion travel if no forces is detected
    #
    #       example:
    #          sk_linear_search()
    #              will movetaught the robot in the Z+ axis of the tool
    #              until the default force is measured by the sensor or default max distance is achieved
    #
    #          sk_linear_search("Y-", force = 20)
    #              will movetaught the robot in the Y- axis of the tool
    #              until 20 Newtons are measured by the sensor or default max distance is achieved
    #
    #          if (not sk_linear_search("Z+", force = 10, speed = 0.010 , max_distance = 0.020)): popup
    #              will movetaught the robot at 10 mm/s in Z+ axis to find 10 Newtons
    #              if the force is not measured within 20 mm, a popup will be shown

    # This variable contains a found location
    global find_location = p[0,0,0,0,0,0]
    # This variable contains the distance value between current and previous found locations
    global find_distance_from_last = 0.0
    # This variable contains the mid point location between the current and previous found locations
    global find_mid_location_from_last = p[0,0,0,0,0,0]
    # This variable contains a measured dimension based on distance between last found location and adjustment variable below
    global find_dimension = 0.0
    # To evaluate the dimension, adjust this variable to subtract the distance between
    # point of contact and TCP, normally 2x.
    global find_dimension_adjust = 0.0268

    #************************************************
    #   Function:  actual_force(direction)
    #   Return the current force measured by the sensor in the specified axis
    #************************************************
    def actual_force(direction="X"):
        if (direction == "X+") or (direction == "x+") or (direction == "X-") or (direction == "x-"):
            return norm(Fx)
        elif (direction == "Y+") or (direction == "y+") or (direction == "Y-") or (direction == "y-"):
            return norm(Fy)
        else:
            textmsg(norm(Fz))
            return norm(Fz)
        end
    end


    #************************************************
    #   Function:  sk_linear_search(direction="Z+", force[N] = 10, speed[m/s] = 0.004, max_distance[m] = 0.02)
    #   Find a specific force in the direction of "direction".
    #   Robot will movetaught towards a max_distance from the current position in the tool frame
    #   Return True if the force is detected during the robot motion
    #************************************************
    def sk_linear_search(direction="Z+",force = 10, speed = 0.004, max_distance = 0.02 ):
        global pos_offset_setting = p[0,0,0,0,0,0]
        if (direction == "X+") or (direction == "x+"):
            pos_offset_setting = p[max_distance,0,0,0,0,0]
        elif (direction == "X-") or (direction == "x-"):
            pos_offset_setting = p[max_distance * -1,0,0,0,0,0]
        elif (direction == "Y+") or (direction == "y+"):
            pos_offset_setting = p[0,max_distance,0,0,0,0]
        elif (direction == "Y-") or (direction == "y-"):
            pos_offset_setting = p[0,max_distance * -1,0,0,0,0]
        elif (direction == "Z+") or (direction == "z+"):
            pos_offset_setting = p[0,0,max_distance,0,0,0]
        elif (direction == "Z-") or (direction == "z-"):
            pos_offset_setting = p[0,0,max_distance * -1,0,0,0]
        else:
            popup("direction parameter must be X+, X-, Y+, Y-, Z+ or Z-","ERROR sk_find")
            halt
        end
        global speed_setting = speed
        #The funtion will return the value True if the force is detected during the motion
        global find_something = True
        #Parameters validation
        if (max_distance < 2):
            if ((speed > 0) and (speed <= 0.1)):
                if ((force > 0) and (force < 200)):
                    #Define a thread to perform the robot motion.
                    #this thread will be stopped if the force is reached
                    global thread_find_flag = 0
                    thread thread_find():
                        #Calculate the position at the max distance to go
                        pose_temp = get_actual_tcp_pose()
                        pose_temp = pose_trans(pose_temp,pos_offset_setting)
                        #Move the robot to that position
                        movel(pose_temp,a=1.2,v=speed_setting)
                        #If the program reaches this line, the force has not been detected during the motion
                        #The function will return the value False
                        find_something = False
                        thread_find_flag = 1
                    end
                    #Set the sensor to zero
                    #sleep(0.1)
                    #sk_set_zero()
                    #sleep(0.05)
                    #Run the thread to movetaught the robot and continuously check the force measured
                    if (actual_force(direction)<force):
                        thread_find_handler = run thread_find()
                        #Loop as long as the force is not detected and thread is not finished
                        while ((actual_force(direction)<force) and (thread_find_flag ==0)):
                            sync()
                        end
                        #The force is detected or max distance is reached, kill the thread to stop the motion
                        kill thread_find_handler
                        if (find_something == True):
                            find_distance_from_last=point_dist(get_actual_tcp_pose(),find_location)
                            find_dimension=find_distance_from_last - find_dimension_adjust
                            find_mid_location_from_last=interpolate_pose(find_location,get_actual_tcp_pose(),0.5)
                            find_location=get_actual_tcp_pose()
                        end
                        stopl(2.2)
                    end
                    #Error message for invalid parameters
                else:
                  popup("Force parameter in Newtons must be between 0 and 200","ERROR sk_find")
                  halt
                end
            else:
                popup("speed parameter in m/s must be between 0 and 0.1","ERROR sk_find")
                halt
            end
        else:
            popup("max_distance parameter in meters must be between 0 and 1.9","ERROR sk_find")
            halt
        end
        #The function will return True if the force is detected during the motion
        #The value returned will be False if the motion reaches the maximum distance without sensing the force
        return find_something
    end

    #************************************************
    #   Function:  correct_force(current_force, force_threshold)
    #   Return remaining force after removing noises
    #************************************************
    def correct_force(current_force=[0,0,0,0,0,0], force_threshold=[0,0,0,0,0,0]):
        return_value = [0,0,0,0,0,0]
        i = -1
        while (i<5):
            i = i+1
            if ((norm(current_force[i])-force_threshold[i])<0):
                return_value[i] = 0
                continue
            end
            if (current_force[i] < 0):
                return_value[i] = (current_force[i]+force_threshold[i])
            else:
                return_value[i] = (current_force[i]-force_threshold[i])
            end
        end
        return return_value
    end

    #**************************************
    # FUNCTION: sk_impedance(stroke, massm, force_threshold = [7,7,7,.1,.1,.1], dampc = [.1,.1,.1,.1,.1,.1], springk = [1,1,1,1,1,1])
    # Description:
    # PARAMETER:
    #   massm: the mass of impedance control
    #   force_threshold : If the maximum force that is counted as 0
    #   dampc, springk : damper and spring coefficients.
    #**************************************
    def sk_impedance(stroke, massm, force_threshold = [3,3,5,.07,.07,.07], dampc = [50,50,50,1,1,1], springk = [100,100,100,100,100,100]):
        i = 0
        while (i<6):
            if ((force_threshold[i]<0) or (force_threshold[i]>40)):
                popup("force_threshold parameter in Newton must be between 0 and 40","ERROR sk_spiral_search")
                halt
            end
            i = i+1
        end
        # prepare
        starting_pos = get_actual_tcp_pose()
        deltat = 0.008
        goalp = p[0,0,0,0,0,0]
        goalpp = p[0,0,0,0,0,0]
        # suppose the object is a 10cm ball
        massmi = [massm, massm, massm, massm/600, massm/600, massm/600]
        while (True):
            current_pos = get_actual_tcp_pose()
            dist = pose_dist(current_pos, starting_pos)
            textmsg("impedance dist")
            textmsg(starting_pos)
            textmsg(current_pos)
            textmsg(norm(dist))
            if (norm(dist) >= stroke):
                halt
            end
            fp = correct_force([Fx,Fy,Fz,Mx,My,Mz],force_threshold)
            fp[2] = fp[2]+50

            mdt2 = [0,0,0,0,0,0]
            cdt = [0,0,0,0,0,0]
            mck = [0,0,0,0,0,0]
            ppmp = pose_sub(goalpp, goalp)
            ppmpmp = pose_sub(ppmp, goalp)
            goal = p[0,0,0,0,0,0]
            # 0
            mdt2[0] = massmi[0]/(deltat*deltat)
            cdt[0] = dampc[0]/deltat
            mck[0] = mdt2[0]+cdt[0]+springk[0]
            goal[0] = (fp[0]-mdt2[0]*ppmpmp[0]+cdt[0]*goalp[0])/mck[0]
            # 1
            mdt2[1] = massmi[1]/(deltat*deltat)
            cdt[1] = dampc[1]/deltat
            mck[1] = mdt2[1]+cdt[1]+springk[1]
            goal[1] = (fp[1]-mdt2[1]*ppmpmp[1]+cdt[1]*goalp[1])/mck[1]
            # 2
            mdt2[2] = massmi[2]/(deltat*deltat)
            cdt[2] = dampc[2]/deltat
            mck[2] = mdt2[2]+cdt[2]+springk[2]
            goal[2] = (fp[2]-mdt2[2]*ppmpmp[2]+cdt[2]*goalp[2])/mck[2]
            # 3
            mdt2[3] = massmi[3]/(deltat*deltat)
            cdt[3] = dampc[3]/deltat
            mck[3] = mdt2[3]+cdt[3]+springk[3]
            goal[3] = (fp[3]-mdt2[3]*ppmpmp[3]+cdt[3]*goalp[3])/mck[3]
            # 4
            mdt2[4] = massmi[4]/(deltat*deltat)
            cdt[4] = dampc[4]/deltat
            mck[4] = mdt2[4]+cdt[4]+springk[4]
            goal[4] = (fp[4]-mdt2[4]*ppmpmp[4]+cdt[4]*goalp[4])/mck[4]
            # 5
            mdt2[5] = massmi[5]/(deltat*deltat)
            cdt[5] = dampc[5]/deltat
            mck[5] = mdt2[5]+cdt[5]+springk[5]
            goal[5] = (fp[5]-mdt2[5]*ppmpmp[5]+cdt[5]*goalp[5])/mck[5]

            rel_pos = pose_sub(goal, goalp)
            next_pos=pose_trans(current_pos,rel_pos)
            movep(next_pos, a=0.4, v=.015, r=0.0)
            goalpp[0] = goalp[0]
            goalpp[1] = goalp[1]
            goalpp[2] = goalp[2]
            goalpp[3] = goalp[3]
            goalpp[4] = goalp[4]
            goalpp[5] = goalp[5]
            goalp[0] = goal[0]
            goalp[1] = goal[1]
            goalp[2] = goal[2]
            goalp[3] = goal[3]
            goalp[4] = goal[4]
            goalp[5] = goal[5]
            textmsg("fp")
            textmsg(fp)
            textmsg("rel and goal")
            textmsg(current_pos)
            textmsg(rel_pos)
            textmsg(next_pos)
            # sleep(deltat)
            sync()
        end
    end

    #**************************************
    # FUNCTION: sk_spiral_search(force_threshold = 3, ShuidiX = 5.0, radius_incr=0.3, peck_mode = False)
    # Description:
    # PARAMETER:
    #   force_threshold : If the force of contact drops below the force threshold, the hole has been found.
    #   max_radius : Determines the maximum search radius.
    #   radius_incr : Increases the trajectory of the search by a given radius per turn.
    #   peck_mode : Enables the retreat of the tool in the z axis before moving to the next point.
    #**************************************
    def sk_spiral_search(force_threshold = 3, max_radius = 5.0, radius_incr=0.3, peck_mode = False):
        if (force_threshold < 0) or (force_threshold > 40):
            popup("force_threshold parameter in Newton must be between 0 and 40","ERROR sk_spiral_search")
            halt
        else:
            if (max_radius < 0.5) or (max_radius > 10):
                popup("max_radius parameter in mm must be between 0.5mm and 10mm","ERROR sk_spiral_search")
                halt
            else:
                if (radius_incr < 0.01) or (radius_incr > 5.0):
                    popup("radius_incr parameter in mm must be between 0.01mm and 5mm","ERROR sk_spiral_search")
                    halt
                else:
                    global max_radius_set = max_radius / 1000
                    global theta_incr=12.5
                    global radius_inc_set = radius_incr / 1000 / (360 / theta_incr)
                    global r=0.0003  #Start radius
                    global z_insert_distance = 0.001  #in meter
                    global x=0
                    global y=0
                    global z=0
                    global pos=p[0,0,0,0,0,0]
                    global next_position=p[0,0,0,0,0,0]
                    global z_Insert=p[0,0,z_insert_distance,0,0,0]
                    global current_pos=p[0,0,0,0,0,0]
                    global theta=0
                    global RealRadius=0
                    global Search_result = False
                    sync()
                    #Find the bore of the part#
                    current_pos=get_actual_tcp_pose()
                    textmsg("Spiral search")
                    sync()
                    while ((RealRadius <= max_radius_set) and (norm(Fz) >= force_threshold)):
                        #By default, the Spiral_Search function will maintain contact between both mating parts at all times
                        if (peck_mode == False):
                            textmsg(norm(Fx))
                            textmsg(norm(Fy))
                            #standard method
                            theta=theta+theta_incr
                            x=cos(d2r(theta))*r
                            y=sin(d2r(theta))*r
                            pos[0] = x
                            pos[1] = y
                            r=r + radius_inc_set
                            RealRadius = sqrt(pow(norm(x),2)+pow(norm(y),2))
                            next_pos=pose_trans(current_pos,pos)
                            movep(next_pos, a=0.6, v=0.025, r=0.0)
                            sleep(0.1)
                            #Operator enables "Peck Mode", the robot will retreat in the Z axis before moving to the next point
                        else:
                            #Fragile mode, the robot rises between each new point
                            #Retreat from position
                            pos[2]= -0.002
                            next_pos=pose_trans(current_pos,pos)
                            movep(next_pos, a=0.6, v=0.025, r=0.0005)
                            sleep(0.1)
                            #movetaught to a new coordinate
                            theta=theta+theta_incr
                            x=cos(d2r(theta))*r
                            y=sin(d2r(theta))*r
                            pos[0] = x
                            pos[1] = y
                            r=r + radius_inc_set
                            RealRadius = sqrt(pow(norm(x),2)+pow(norm(y),2))
                            next_pos=pose_trans(current_pos,pos)
                            movep(next_pos, a=0.6, v=0.025, r=0.0005)
                            sleep(0.1)
                            #Re-establish contact with the part
                            pos[2]= 0.0005
                            next_pos=pose_trans(current_pos,pos)
                            movep(next_pos, a=0.6, v=0.01, r=0.0)
                            sleep(0.2)
                        end
                    end
                    if (RealRadius <= max_radius_set):
                        current_pos=get_actual_tcp_pose()
                        next_position=pose_trans(current_pos,z_Insert)
                        movel(next_position, a=0.05, v=0.005)
                        Search_result = True
                    else:
                        Search_result = False
                    end
                    return Search_result
                end
            end
        end
    end

    #**************************************
    # FUNCTION: sk_torque_turning(mz_threshold=0.2, rotation = "cw")
    # Description:  The robot will rotate a number of half turn of his joint 6
    #               until the measured torque exceed the value of mz_threshold.
    #               The gripper will also close before the motion and reopen after each half turn
    # PARAMETER:
    #   mz_threshold : this torque value must be reached to end the torque spinning
    #   rotation :  direction of rotation, "ccw" or "cw"
    #**************************************
    def sk_torque_turning(mz_threshold=0.2, rotation = "cw"):
        global gripper_start_pos = 0
        global rotation_set = rotation
        if ((mz_threshold<=0) or (mz_threshold > 10)):
            popup("parameter mz_threshold too high or too low")
            halt
        else:
            if ((rotation != "ccw") and (rotation != "CCW") and (rotation != "cw") and (rotation != "CW")):
                popup("parameter rotation must be 'cw' or 'ccw'")
                halt
            else:
                global pos_init = get_actual_tcp_pose()
                #Store the actual gripper opening
                gripper_start_pos = sk_current_pos("1")
                #Define thread for tightening motion
                thread Thread_ts_1():
                    while (True):
                        sync()
                        sk_close_and_wait("1")
                        sync()
                        if (rotation_set == "ccw") or (rotation_set == "CCW"):
                          pose_spin = pose_trans(pos_init,p[0,0,0,0,0,-3.1])
                        else:
                          pose_spin = pose_trans(pos_init,p[0,0,0,0,0,3.1])
                        end
                        movej(pose_spin,a=1.4,v=3.1)
                        stopl(5.0)
                        #Return the gripper to his start position
                        sk_move_and_wait(gripper_start_pos,"1")
                        movej(pos_init, a=3.14, v=3.14)
                    end
                end
                #Launch the tightening thread and monitor Mz to stop tightening when the torque reach Mz_threshold
                if (norm(Mz) <= mz_threshold):
                    global thread_handler_ts=run Thread_ts_1()
                    while (norm(Mz) <= mz_threshold):
                        sync()
                    end
                    kill thread_handler_ts
                end
                #Torque reached, Return the gripper and robot to their start position
                stopl(5.0)
                sk_move_and_wait(gripper_start_pos,"1")
                movej(pos_init, a=3.14, v=3.14)
            end
        end
    end

    while (True):
        sk_linear_search("Z+",10,0.02,0.4)
        stroke = parameter_stroke
        if sk_spiral_search(10,7,.3,peck_mode=True):
            #Insert the Part into the bore#
            textmsg("Impedance insert")
            massm = parameter_massm
            sk_impedance(stroke, massm)
        end
        textmsg("running")
    end
end